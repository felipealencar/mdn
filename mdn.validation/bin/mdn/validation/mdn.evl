context NetworkNode {
	critique hasName {
		check : self.name.isDefined()
		message : 'Unnamed ' + self.eClass().name.toUpperCase() + ' not allowed'
		fix {
        	title : 'Define the name of the nod '
          	do {
            	var type := UserInput.prompt('What is the name?');
              	if (type.isDefined()) self.type := type;
          	}
      	}
	}
	
	constraint notNullIP {
		check : self.ip.isDefined()
		message : 'Invalid IP in ' + self.eClass().name.toUpperCase()
		fix {
        	title : 'Define the IP of the node '
          	do {
            	var ip := UserInput.prompt('What is the IP?');
              	if (ip.isDefined()) self.ip := ip;
          	}
      	}
	}
	
	constraint uniqueMAC {
		check {
			var networkNodes = NetworkNode.all.select(nn|nn.mac = self.mac);
			
			return networkNodes.size() = 1;
		}
		message : 'Not unique MAC "' + self.mac + '" not allowed'
		fix {
        	title : 'Define the correct MAC '
          	do {
            	var mac := UserInput.prompt('What is the MAC?');
              	if (mac.isDefined()) self.mac := mac;
          	}
      	}
	}
} 

context Controller {
	critique checkType {
		check {
			if(self.type <> 'PROACTIVE' or self.type <> 'REACTIVE'){
				return false;
			}
			return true;
		}
		message : 'Controller type should be REACTIVE or PROACTIVE'
		fix {
        	title : 'Define the controller type '
          	do {
            	var type := UserInput.prompt('REACTIVE or PROACTIVE?');
              	if (type.isDefined()) self.type := type;
          	}
      	}
	}
}

context Switch {
	constraint maxNumPorts {
		check {
			if(self.ports > 65280){
				return false;
			}
			return true;
		}
	}
}

context Host {
	constraint noIdenticalIpsConnectedToSwitch {
		check {
			var networkNodes = Host.all.select(h|h.ip = self.ip);
			if(networkNodes.size() > 1){
				var hostSwitch = 0;
				for (host in networkNodes) { 
					if(host.hostSwitch <> hostSwitch)
						hostSwitch = host.hostSwitch;
					else
						return false; 
				}
			}
			return true;
		}
		message : 'More than one identical IP "' + self.ip + '" connected to switch'
		fix {
        	title : 'Define the correct IP '
          	do {
            	var ip := UserInput.prompt('What is the IP?');
              	if (ip.isDefined()) self.ip := ip;
          	}
      	}
	}
}

context Rule {
	constraint ruleWithOneSourceHostRequiresDifferenteTargetHost {
		check {
			var policies = Rule.all.select(p|p = self);
			var sourceHosts = 0;
			var targetHosts = 0;
			for (p in policies) { 
				sourceHosts = p.sourceHostRule;
				targetHosts = p.targetHostRule;
				if(sourceHosts.size() = 1){
					for (tH in targetHosts) { 
						if(sourceHosts.ip = tH.ip or sourceHosts.ip = null or tH.ip = null){
							return false;
						}
					}
				}
			}
			return true;
		}
		message : 'Policies can not be null and/or have the same source and target nodes. Change some.'
	}
	
	constraint hasOneCondition {
		check {
			var policies = Rule.all.select(p|p = self);
			var conditions = 0;
			for (p in policies) { 
				conditions = p.ruleCondition;
				if(conditions.size() > 1){
					return false;
				}
			}
			return true;
		}
		message : 'Policies can only have one Condition'
	
	}
	critique hasName {
		check : self.name.isDefined()
		message : 'Unnamed ' + self.eClass().name.toUpperCase() + ' not allowed'
		fix {
        	title : 'Define the name of the rule '
          	do {
            	var name := UserInput.prompt('What is the name?');
              	if (name.isDefined()) self.name := name;
          	}
      	}
	}
}

context Time {
	constraint validDate {
		check : self.dateToInt(self.beginDate, self.endDate) 
		message : 'The Time clause requires that begin date less than end data.'
	}
}

context Traffic {
	constraint validValue {
		check : self.value > 0
		message : 'The value of traffic can not be less than or equal to 0.'
		fix {
        	title : 'Define the correct value for traffic '
          	do {
            	var value := UserInput.prompt('What is the value for traffic?');
              	if (value.isDefined()) self.header := header;
          	}
      	}
	}
	constraint validUnit {
		check {
			var unit = self.unit;
			unit = unit.toUpperCase(); 
			if(unit <> 'MB' or self.unit <> 'GB') {
				return false;
			}
			return true;
		}
		message : 'The unit of traffic can not be different from MB or GB.'
		fix {
        	title : 'Define the correct unit for traffic '
          	do {
            	var unit := UserInput.prompt('What is the unit?');
              	if (unit.isDefined()) self.unit := unit;
          	}
      	}
	}
}

context PacketHeader {
	constraint validValue {
		check : self.value > 0
		message : 'The value of '+ self.header +' can not be less than or equal to 0.'
		fix {
        	title : 'Define the correct value for packet header '
          	do {
            	var value := UserInput.prompt('What is the value for packet header' + self.header + '?');
              	if (value.isDefined()) self.header := header;
          	}
      	}
	}
	
}

context Action {
	constraint ifActionEqualToModifyThenActionPacketHeaderCanNotBeNull {
		check {
			if(self.type.asString() = 'MODIFY' and self.actionPacketHeader = null) {
				return false;
			}
			return true;
		}
		message : 'The MODIFY action needs to relate with a packet header.'
	}
	constraint ifActionEqualToForwardThenActionForwardToNodeCanNotBeNull {
		check {
			if(self.type.asString() = 'FORWARD' and self.actionForwardToNode = null) {
				return false;
			}
			return true;
		}
		message : 'The FORWARD action needs to relate with a host.'
	}
}

operation Any println() : Any {
	("Printing : " + self)->println();
}

operation Any dateToInt(beginDate : Any, endDate : Any) : Boolean {
	var date = new Native("java.util.Date");
	date = beginDate;
	if(date.compareTo(endDate) <= 0){
		return true;
	}
	else
		return false;
	
}